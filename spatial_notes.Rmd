---
title: "Spatial workshop 2: polygons, shapefiles, and other such nonsense"
output: html_document
---
```{r setup, echo = FALSE, message = FALSE}
library(dplyr)
library(tidyr)
library(stringr)
```

### Global maps at lower resolution

Find lower-resolution global shapefiles in [ohiprep/globalprep/spatial/downres](https://github.com/OHI-Science/ohiprep/tree/master/globalprep/spatial/downres).  Filename contains info on what regions it covers (all, EEZ, Antarctica, FAO, land), resolution (low and medium), and CRS (lat-long GCS and Mollweide).

Look for med resolution, mol projection (for global equal area), and pull the .shp, .dbf, and .shx files.  The medium resolution files are ~ 11 MB for global coverage, so not huge but also detailed enough for zooming in a bit.

Note that there is no .prj file - so no projection information will come along with these files.  There are two sets of coordinate reference systems:

* mol: Mollweide: equal area projection, units in meters.  
    * EPSG:54009
    * proj.4 string: `'+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs'`
* gcs: lat and long in degrees
    * EPSG:4326 WGS 84
    * proj.4 string: `'+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'`

# Shapefiles and polygons in R

### Reading shapefiles

Here are two different ways to read in spatial vector data, each with advantages and disadvantages:
```{r read shapefiles 1}
library(rgdal)
dir_spatial   <- '~/github/spatial_analysis2_R/spatial_data'
layer_bc <- 'ohibc_rgn'

poly_bc_rgn <- readOGR(dsn = path.expand(dir_spatial), layer = layer_bc, stringsAsFactors = FALSE)
  ### note the path.expand(): readOGR can be annoyingly finicky about file names;
  ### it is apparently not a fan of the '~'.  path.expand() gets rid of that.

### you can easily plot polygons, though complex polys take a while
plot(poly_bc_rgn, col = 'light blue', border = 'blue')
```

* `dsn` is the data source name.  It can be a .gdb or a directory with shapefiles in it.  It can be relative or absolute file path.
* `layer` is the layer name.  
    * If you're reading from a .gdb, you can tell it which layer to pull out of that .gdb 
        * `ogrListLayers()` can help identify the layers within the .gdb if you're not sure.
    * If you're reading a .shp (and the associated .dbf etc), then `layer` should be the base name of the shapefile (without the .shp extension).  E.g. if you want `rgn_all_mol_med_res.shp`, then `layer = 'rgn_all_mol_low_res'`.
* `p4s` allows you to input a proj.4 string to indicate a CRS.  If there's already a .prj file associated with this layer, `readOGR()` will automatically read it in.

```{r read shapefiles 2}
library(maptools)
shp_bc <- file.path(dir_spatial, layer_bc)
p4s_bc <- CRS('+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0')
  ### that's the proj4string for BC Albers projection

poly_bc_rgn <- readShapePoly(fn = shp_bc, proj4string = p4s_bc)

```

* `fn` is the full filename, leaving off the .shp extension.  This has to be a shapefile (not a .gdb).
* `proj4string` is an optional proj.4 CRS designation.  
    * `readShapePoly()` does not read .prj files, so it will not know the projection unless you manually tell it.  
    * This argument has to be a CRS object, so for example, if you want to set Mollweide you would use: `proj4string = CRS('+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs')`
    
`readOGR()` and `readShapePoly()` also have analogous `write` functions and the like.

`readShapePoly()` seems to be significantly faster for big shapefiles, but doesn't work on .gdb and doesn't automatically read in CRS info, which `readOGR()` can do.  I prefer to stick with `readOGR()` where possible (especially for smaller files) to use projection/CRS information where it is available.

One note, learned the annoying painful way, is that if you wish to read layers from a geodatabase (.gdb), you need to have GDAL version 1.11 or higher installed on your computer (outside of R).  In that version, they included the driver for the OpenFileGDB file format.  As of this writing, Neptune's GDAL version is only 1.10, though hopefully it will be updated soon, when the OS etc is updated.

### Understanding Spatial Polygons in R

Once the shapefile is read in, it becomes a SpatialPolygonsDataFrame object (from the `sp` package).  SpatialPolygonsDataFrame store shape info and attributes in different slots, with a structure like this:

* `SpatialPolygonsDataFrame` (top level structure)
    * `@data`: a dataframe that holds the attribute table; each row correlates with a polygon in the `polygons` slot.
    * `@polygons`: a list of Polygons-class objects, each with their own bits and pieces.  Each item in the list is a complete polygon feature, made up of sub-polygons; and each item in the list corresponds with a row in the dataframe in the `data` slot.
    * `@plotOrder`: a vector of integers showing which order to plot the `polygons` list
    * `@bbox`: info on the bounding coordinates (x & y min & max).
    * `@proj4string`: a CRS object that contains projection or coordinate system info
    
![SpatialPolygonsDataFrame structure](spdf_sketch.png)

Each of these slots can be accessed by a `@` symbol (rather than a `$` symbol).  If your SpatialPolygonsDataFrame is called `x`, then you can access the attribute table by calling `x@data` and treat it exactly like a regular data frame (though be wary of operations that might change the order or length of the data frame - confusion and chaos will reign!)

```{r viewing SpatialPolygonsDataFrame slots}
### view the overall structure
summary(poly_bc_rgn)

### check out the attribute table in the data slot
head(poly_bc_rgn@data)

### check out the basics of the polygon features
summary(poly_bc_rgn@polygons)  ### summary of the polygon features

### inspect one of the smaller sub-polys that make up the first polygon
### feature; this one draws a small hole in the main polygon
poly_bc_rgn@polygons[[1]]@Polygons[[2]] 

### check out the CRS info
poly_bc_rgn@proj4string
```

You can also manipulate these slots individually, for example filtering out rows of the dataframe in the `data` slot, but you will also need to treat the other slots accordingly.

### Adding data to polygons

If you'd like to add a column of data to the SpatialPolygonsDataFrame, for example harvest tonnes or a region ID value, you should be able to simply access the `data` slot and treat it like a data frame.
```{r adding data to SpatialPolygonsDataFrame}
### create a data frame of harvest per region.  Note not all regions are represented here!
harv_data <- data.frame(rgn_id   = c(  1,  2,  3,  5,  8),
                        h_tonnes = c(105, 89, 74, 21, 11))

### use left_join to join data to attributes table without changing order
poly_bc_rgn@data <- poly_bc_rgn@data %>%
  left_join(harv_data, by = 'rgn_id')

### note unassigned regions have NA for harvest tonnage
poly_bc_rgn@data
```

### Selecting or filtering polygons based on attributes

Use indexing to select just rows where there is harvest data.  This eliminates the polygons as well as the attribute table rows, and resets the plot order.  Probably safer than filtering on the data slot directly...

```{r selecting/filtering by attribute}
### Select only regions with non-NA harvest values
poly_bc_harvest <- poly_bc_rgn[!is.na(poly_bc_rgn@data$h_tonnes), ]

poly_bc_harvest@data

```

### Fixing projections

Mismatched coordinate reference systems are just as much a pain in the ass in R as they are in ArcGIS or QGIS.  But they're easy to work with once you know how to inspect them and re-project them.

```{r fixing projections}

poly_bc_mpa <- readShapePoly(file.path(dir_spatial, 'mpa_bc'))

plot(poly_bc_rgn, col = rgb(.7, .7, 1), border = rgb(0, 0, 1))
plot(poly_bc_mpa, col = rgb(1, .5, .5, .5), border = rgb(1, 0, 0, .5), add = TRUE)
  ### fun fact: the 'rgb()' function allows you to specify color by 
  ### Red/Green/Blue proportions, but also allows a fourth argument
  ### for 'alpha' (opacity) to create semi-transparent layers

### Note that the MPA polys don't show up on the map!  That's because of a
### CRS error...
poly_bc_mpa@proj4string ### NA!  But it's actually in lat-long coord system.
poly_bc_mpa@proj4string <- CRS('+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0')

### Now that it knows the correct CRS we can reproject to BC Albers:
poly_bc_mpa <- spTransform(poly_bc_mpa, p4s_bc)
poly_bc_mpa@proj4string
poly_bc_rgn@proj4string  ### OK, now they match!

plot(poly_bc_rgn, col = rgb(.7, .7, 1), border = rgb(0, 0, 1))
plot(poly_bc_mpa, col = rgb(1, .5, .5, .3), border = NA, add = TRUE)
  ### The semi-transparency not only looks way awesome, but also
  ### allows us to see whether there are any overlapping polygons!
```


# Rasters and polygons

Extracting raster data into regions defined by a SpatialPolygons* object is pretty easy, using the `extract()` function from the `raster` package.  In next few code chunks we'll determine the extent of marine protected areas within each analysis region in BC's EEZ.

While it is possible to use vector geoprocessing to figure this out, overlapping polygons could be double-counted, so I will instead rasterize the MPA polygons, prioritizing the earliest date of protection.  First step - establish a base raster.

### Creating a raster from scratch

```{r set up base raster}
library(raster)

### use poly_bc_rgn to set raster extents and then round to nearest km
ext <- extent(poly_bc_rgn) 
ext@xmin <- round(ext@xmin - 500, -3); ext@ymin <- round(ext@ymin - 500, -3)
ext@xmax <- round(ext@xmax + 500, -3); ext@ymax <- round(ext@ymax + 500, -3)

reso <- 1000 ### BC Albers uses meters as units, set a 1-km grid
xcol <- (ext@xmax - ext@xmin)/reso; yrow <- (ext@ymax - ext@ymin)/reso

rast_base <- raster(ext, yrow, xcol, crs = p4s_bc)

rast_base ### inspect it: resolution and extents are nice and clean
```

### Rasterize polygons

Next step: rasterize the MPA polygons.  See later in the doc for an alternative to raster::rasterize() that is way faster, avoids some odd problems, but has a fairly important limitation.

```{r rasterize MPA polygons}
rast_bc_mpa <- rasterize(poly_bc_mpa, rast_base, field = 'STATUS_YR', fun = 'min')
```

### The gloriousness of raster::extract()
Now the big step: raster::extract()

Note that `extract()` is also a function in the `tidyr` package and elsewhere; so I generally force the issue by calling `raster::extract()` just to make sure.

The basic arguments are simply the raster with the interesting data, and the polygon features that define the regions of interest.  There are other arguments, but one set of arguments that may be interesting is `weights` and/or `normalizeWeights`.

* `weights` (logical): if `weights = TRUE`, provides info on how much of a cell was covered by the polygon in question.
* `normalizeWeights`  (logical): if `normalizeWeights = TRUE` then the reported weights will be normalized for each polygon, so the total for each polygon adds up to 1.00.  If you just want the fraction of cell coverage for each cell, set `normalizeWeights = FALSE`.

It's a bit processor-intensive so be patient...

```{r raster::extract()}
### for this, let's see how much area within 3 nautical miles of the coast
### is designated as a protected area.
poly_bc_3nm <- readShapePoly(fn = file.path(dir_spatial, 'ohibc_offshore_3nm'), proj4string = p4s_bc)

mpa_by_rgn <- raster::extract(rast_bc_mpa, poly_bc_3nm)

# mpa_by_rgn_weights <- raster::extract(rast_bc_mpa, poly_bc_3nm, weights = TRUE, normalizeWeights = FALSE)
```

### Turning raster::extract output into something useful

`raster::extract()` returns a list of vectors; each list item is a vector of all the cell values contained within one of the polygon features (`poly_bc_3nm@polygons`).  At this point, we need to assign a non-generic name to our list items so we can keep track.  The following line names the list items according to the `rgn_id` column in the attribute table contained in `poly_bc_3nm@data` (this works since the list is in order of items in the `polygons` slot, which is the same order of attributes in the `data` slot).

```{r name list elements from raster::extract}
names(mpa_by_rgn) <- poly_bc_3nm@data$rgn_id

# names(mpa_by_rgn_weights) <- poly_bc_3nm@data$rgn_id
```

To get the data out of annoying list form and into convenient data frame form, this next code chunk does the following:

* create an empty data frame (`mpa_rgn_df`) that we will build up as we unlist each list item.
* loop over each of the list items (named after the `rgn_id`s in the previous step)
    * create a temporary data frame that stores the `rgn_id` (from loop index) and the entire list of cell values for that particular `rgn_id`
    * tack that temp data frame onto the bottom of the existing `data_rgn_df` (first time through, tacks onto an empty data frame)

VoilÃ ! a data frame of cell values by region.

```{r convert list elements to data frame}
### For the dataframe without cell weights, each list is just a
### vector of values, so we can simply assign that to a column in
### the data frame.
mpa_rgn_df <- data.frame()
for (rgn_id in names(mpa_by_rgn)) {
  temp_df <- data.frame(rgn_id, year = unlist(mpa_by_rgn[[rgn_id]]))
  mpa_rgn_df <- rbind(mpa_rgn_df, temp_df)
}

### for the dataframe with cell weights, each list item is a 
### matrix containing value & weight, so we can unlist it into a temp
### matrix and then assign each variable separately.  
# mpa_rgn_weights_df <- data.frame()
# for (rgn_id in names(mpa_by_rgn_weights)) {
#   temp_matrix <- unlist(mpa_by_rgn_weights[[rgn_id]])
#   temp_df <- data.frame(rgn_id, year = temp_matrix$value, wt = temp_matrix$weight)
#   mpa_rgn_df <- rbind(mpa_rgn_weights_df, temp_df)
# }
```

# Further examples

To see much of this stuff put into action, check out [OHIBC LSP script](https://github.com/OHI-Science/ohibc/blob/master/lsp/data_prep_lsp.R) and its [associated functions](https://github.com/OHI-Science/ohibc/blob/master/lsp/R/lsp_fxns.R).

For a more complex version that maintains the spatial distribution of the data, check out [OHI global 2015 SPP_ICO goal script](https://github.com/OHI-Science/ohiprep/blob/master/globalprep/SPP_ICO/data_prep_SPP.R) and its [associated functions](https://github.com/OHI-Science/ohiprep/blob/master/globalprep/SPP_ICO/R/spp_fxn.R).  In these scripts, a raster of cell IDs is extracted against polygons for many different species; the resulting lists tell which cell IDs contain which species.

This [downres_polygons.R script](https://github.com/OHI-Science/ohiprep/blob/master/globalprep/spatial/downres_polygons.R) was used to simplify the high resolution global polygon shapefiles (308 MB of polygon fun) into [lower resolution files](https://github.com/OHI-Science/ohiprep/tree/master/globalprep/spatial/downres) (.7 MB and 11 MB versions) for quicker plotting.  While the script itself may not be all that useful to you, there are plenty of examples of digging into and manipulating the details of SpatialPolygonsShapeFile objects.  The script first examines each polygon feature, and strips out sub-polygons whose area falls below a certain threshold; then it simplifies the geometry of the remaining polygons using a [Douglas-Peuker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm).

# Appendix

### Alt method of rasterizing polygons

Most of what you need to know about rasters is covered in Jamie's spatial data workshop.  One added point: an alternative method of rasterizing vector data, when `raster::rasterize()` is causing problems.

Note that one major issue with `gdal_rasterize()` (aside from the arcane argument list) is that in the event of overlapping polygons, there's no place for a decision rule as to which polygon value gets assigned to the cell.  If you know there are no overlaps, then this is a very fast and seemingly accurate option.

```
library(gdalUtils)
rast_3nm_gdal <- gdal_rasterize(
    src_datasource = file.path(dir_spatial, 'ohibc_offshore_3nm.shp'),
      # src_datasource needs to be an OGR readable format (e.g. .shp)
      # NOTE: doesn't need source to already be in memory!
    dst_filename = file.path(dir_spatial, 'rast_3nm_gdal.tif'), 
      # destination for output
    a = 'rgn_id', 
      # the attribute in the shapefile to be assigned to the cell values
    te = c(ext@xmin, ext@ymin, ext@xmax, ext@ymax), 
      # extents for output raster
    tr = c(1000, 1000),   
      # resolution for x and y; for my projection, 500 m resolution
    tap = TRUE, 
      # target aligned pixels - align coords of extent of output to values of -tr
    a_nodata = NA, 
      # nodata value for raster; otherwise they will be filled in with zeroes
    output_Raster = TRUE, 
      # return output as a RasterBrick? 
    verbose = TRUE)
  ### unused but interesting arguments:
    # l,     # layer; maybe needed if src_datasource is .gdb, with mult layers
    # of,    # output format; default = GTiff, so I left it stay as default
    # a_srs  # override projection
```

### More fun with shapefiles and polygons

The `rgeos` package has some helpful functions for manipulating SpatialPolygons - including ways to check invalid geometries and typical GIS tools for checking and manipulating geometries, such as `gUnion()`, `gDifference()`, `gIntersection()`, `gBuffer()`, etc.

Sometimes shape files have errors - common ones are too few points and self-intersections.  `rgeos::gIsValid()` can tell you whether the SpatialPolygons* object is valid or not, but it can't fix it directly.

* An internet search might show you a few ways to repair invalid geometries, but some (like setting a buffer of zero width) have unintended consequences - that one just deletes offending polygons entirely.  Not cool, bro!
* The `cleangeo` package has tools for identifying problems, and has a tool to repair geometries.
    * It's not on CRAN but you can install from github.

``` { r identifying and fixing errors}
library(rgeos)
gIsValid(poly_bc_rgn, byid = TRUE) 
  ### checks valid geometries; in this case, two polygon features
  ### have invalid geometries... how to fix 'em? cleangeo!

library(cleangeo) ### devtools::install_github('eblondel/cleangeo') 
poly_bc_rgn_clean <- clgeo_Clean(poly_bc_rgn, print.log = TRUE)
gIsValid(poly_bc_rgn_clean, byid = TRUE) ### all good, yay!

### cleangeo provides an alternate way of checking geometries if
### gIsValid isn't good enough for you
report  <- clgeo_CollectionReport(poly_bc_rgn)
View(report)
issues  <- report %>% filter(valid == FALSE)
issues ### two polygons with problems
```

### Plotting polygons with ggplot2

`ggplot` works with data frames; so if you want to plot a polygon, you need to first turn it into a data frame. `ggplot2::fortify()` takes care of this.  The `region` argument lets you assign a variable within the attribute table to become a region identifier.

Note: make sure you have all your CRS and projection stuff figured out first!

```{r plotting polygons in ggplot}
library(ggplot2)
library(RColorBrewer)

### Fortify the existing poly_bc_rgn SpatialPolygonsDataFrame into a
### data frame that ggplot can work with.  
poly_rgn_df <- fortify(poly_bc_rgn, region = 'rgn_id') %>%
  rename(rgn_id = id) %>%
  mutate(rgn_id = as.integer(rgn_id)) 

### Note: Even though we already have a map with harvest data attached,
### I'm not sure that there's a good way to keep all the attributes
### so I'm just left-joining some harvest data to the fortified data frame.
n_rgn <- length(poly_bc_rgn@data$rgn_id)
harv_data2 <- data.frame(rgn_id   = c(1:n_rgn),
                         h_tonnes = abs(rnorm(n = n_rgn, mean = 100, sd = 80)))

poly_rgn_df <- poly_rgn_df %>%
  left_join(harv_data2, by = 'rgn_id')

head(poly_rgn_df)
  
### To plot land forms, let's load a land shapefile too.
poly_land    <- readShapePoly(fn = file.path(dir_spatial, 'ohibc_land'), proj4string = p4s_bc)
poly_land_df <- fortify(poly_land)

df_plot <- ggplot(data = poly_rgn_df, aes(x = long, y = lat, group = group, fill = h_tonnes)) +  
  theme(axis.ticks = element_blank(), axis.text = element_blank(),
        text = element_text(family = 'Helvetica', color = 'gray30', size = 12),
        plot.title = element_text(size = rel(1.5), hjust = 0, face = 'bold'),
        legend.position = 'right') + 
  scale_fill_gradientn(colours = brewer.pal(10, 'RdYlBu'), space = 'Lab', 
                       na.value = 'gray80') + 
  geom_polygon(color = 'gray80', size = 0.1) +
  geom_polygon(data = poly_land_df, color = 'gray40', fill = 'gray45', size = 0.25) +
    ### df_plot order: EEZ score polygons, then land polygons (dark grey).
  labs(title = 'OHI BC harvest by region', 
       fill  = 'Harvest (tonnes)',
       x = NULL, y = NULL)
         

df_plot

### ggsave() saves the most recent ggplot object
ggsave(file.path(dir_spatial, 'bc_harvest.png'), width = 10, height = 6)
```